import{_ as p,r as m,p as e,q as l,w as a,I as u,J as t,H as n,R as f,s as v}from"./framework-aa5c4115.js";const d=v("h1",null,"列表渲染v-for",-1),g=v("li",{class:"divider",role:"presentation"},null,-1),B={__name:"列表渲染v-for",setup(F){const s=m([{message:"Foo"},{message:"Bar"}]),i=m("父级");return s.value.forEach((c,_)=>{console.log(i.value,c.message,_)}),(c,_)=>(e(),l(u,null,[d,a("1. v-for循环数组的每一项 "),a(" 打印出：Foo Bar "),(e(!0),l(u,null,t(s.value,r=>(e(),l("div",null,n(r.message),1))),256)),a("2. 解构赋值直接渲染 "),a(" 打印出：Foo Bar "),(e(!0),l(u,null,t(s.value,({message:r})=>(e(),l("div",null,n(r),1))),256)),a(" 3. 添加索引的渲染 "),a(" 打印出：父级Foo - 0  父级Bar - 1 "),(e(!0),l(u,null,t(s.value,(r,o)=>(e(),l("div",null,n(i.value)+n(r.message)+" - "+n(o),1))),256)),a(" 3.也可以用解构赋值 "),a(" 打印出：父级Foo - 0  父级Bar - 1 "),(e(!0),l(u,null,t(s.value,({message:r},o)=>(e(),l("div",null,n(i.value)+n(r)+" - "+n(o),1))),256)),a(" 4.对于多层嵌套的 v-for，作用域的工作方式和函数的作用域很类似。每个 v-for 作用域都可以访问到父级作用域： "),(e(!0),l(u,null,t(s.value,r=>(e(),l("li",null,[(e(!0),l(u,null,t(r.message,o=>(e(),l("span",null,[a(" 打印出：Foo Bar "),f(" "+n(o),1)]))),256))]))),256)),a(" 4. 也可以使用 of 作为分隔符来替代 in，这更接近 JavaScript 的迭代器语法： "),(e(!0),l(u,null,t(s.value,r=>(e(),l("div",null,[(e(!0),l(u,null,t(r.message,o=>(e(),l("span",null,[a(" 打印出：Foo Bar "),f(" "+n(o),1)]))),256))]))),256)),a(`5. <template> 上的 v-for\r
         与模板上的 v-if 类似，你也可以在 <template> 标签上使用 v-for 来渲染一个包含多个元素的块 `),v("ul",null,[(e(!0),l(u,null,t(s.value,r=>(e(),l(u,null,[v("li",null,n(r.message),1),g],64))),256))])],64))}},x=p(B,[["__file","列表渲染v-for.vue"]]);export{x as default};
