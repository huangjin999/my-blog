import{_ as e,p as a,q as i,Y as t}from"./framework-aa5c4115.js";const r="/my-blog/images/生命周期.png",d={},l=t(`<h2 id="生命周期" tabindex="-1"><a class="header-anchor" href="#生命周期" aria-hidden="true">#</a> <strong>生命周期</strong></h2><h3 id="初始化阶段" tabindex="-1"><a class="header-anchor" href="#初始化阶段" aria-hidden="true">#</a> 初始化阶段</h3><ol><li>beforeCreate（初始化methods中的方法和初始化生命周期的钩子函数）只会执行一次</li><li>created 1.发ajax请求 2.获取路由参数...</li></ol><h3 id="挂载阶段" tabindex="-1"><a class="header-anchor" href="#挂载阶段" aria-hidden="true">#</a> 挂载阶段</h3><ol start="3"><li>beforeMount</li><li>mounted 表示真实DOM已挂载完毕 1）发ajax请求 2）开定时器 3）DOM操作 4）建立websocket连接 5）实例化echarts实例 只会执行一次</li></ol><h3 id="更新阶段" tabindex="-1"><a class="header-anchor" href="#更新阶段" aria-hidden="true">#</a> 更新阶段</h3><ol start="5"><li>beforeUpdate 数据变化，一定会触发beforeUpdate</li><li>updated</li></ol><ul><li>updated之前，要生成新的虚拟DOM，新的虚拟DOM和老的虚拟DOM进行对比，会执行patch运算，diff算法，找到两个虚拟DOM的最小差异，</li><li>找到后，进行异步更新，v-for循环要写key的目的就是最快找到最差异，但是有点类似于watch侦听器或类似于$nextTick()，但是不能在这个钩子中更新数据，会导致死循环。</li></ul><h3 id="销毁阶段" tabindex="-1"><a class="header-anchor" href="#销毁阶段" aria-hidden="true">#</a> 销毁阶段</h3><ol start="7"><li>beforeDestroy （当我们手动调用$destory()或路由切换时会调用beforeDestroy ，还可以清空定时器 解除事件绑定 清缓存..</li><li>destroyed</li></ol><ul><li><p>销毁后，并不是说界面看不见了，vm实例还可以访问，但是它不工作了。</p></li><li><div class="language-txt line-numbers-mode" data-ext="txt"><pre class="language-txt"><code>* 与动态组件有关的两个特殊的钩：activated(激活)、deactivated(休眠)
* 与组件异常捕获有关的一个钩子：errorCaptured
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><p><strong>生命周期示意图</strong><img src="`+r+'" alt="如图"></p>',12),o=[l];function s(n,c){return a(),i("div",null,o)}const u=e(d,[["render",s],["__file","index_03.html.vue"]]);export{u as default};
