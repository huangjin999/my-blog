import{_ as e,p as i,q as a,Y as l}from"./framework-aa5c4115.js";const n="/my-blog/images/三次握手.png",d="/my-blog/images/四次挥手.png",r={},s=l('<h2 id="一次完整的http服务过程" tabindex="-1"><a class="header-anchor" href="#一次完整的http服务过程" aria-hidden="true">#</a> 一次完整的HTTP服务过程</h2><h2 id="当我们在web浏览器的地址栏中输入-www-baidu-com-具体发生了什么" tabindex="-1"><a class="header-anchor" href="#当我们在web浏览器的地址栏中输入-www-baidu-com-具体发生了什么" aria-hidden="true">#</a> 当我们在web浏览器的地址栏中输入：www.baidu.com，具体发生了什么？</h2><ul><li>对www.baidu.com这个网址进行DNS域名解析，得到对应的IP地址</li><li>根据这个IP，找到对应的服务器，发起TCP的三次握手</li><li>建立TCP连接后, 发起HTTP请求</li><li>服务器响应HTTP请求，浏览器得到html代码</li><li>浏览器解析html代码，并请求html代码中的资源（如js、css、图片等）（先得到html代码，才能去找这些资源）</li><li>浏览器对页面进行渲染呈现给用户</li><li>服务过程完毕, 关闭TCP连接, 四次挥手</li></ul><h2 id="三次握手" tabindex="-1"><a class="header-anchor" href="#三次握手" aria-hidden="true">#</a> 三次握手</h2><p><img src="'+n+'" alt="三次握手"></p><ol><li>第一次握手：建立连接时，客户端发送syn包（syn=x）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。</li><li>第二次握手：服务器收到syn包，必须确认客户的SYN（ack=x+1），同时自己也发送一个SYN包（syn=y），即SYN+ACK包，此时服务器进入SYN_RECV状态；</li><li>第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=y+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。</li></ol><h2 id="四次挥手" tabindex="-1"><a class="header-anchor" href="#四次挥手" aria-hidden="true">#</a> 四次挥手</h2><p><img src="'+d+`" alt="四次挥手"></p><ol><li>客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。</li><li>服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。</li><li>客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。</li><li>服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。</li><li>客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。</li><li>服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。</li></ol><h2 id="常见面试题" tabindex="-1"><a class="header-anchor" href="#常见面试题" aria-hidden="true">#</a> 常见面试题</h2><h3 id="_1-为什么连接的时候是三次握手-关闭的时候却是四次握手" tabindex="-1"><a class="header-anchor" href="#_1-为什么连接的时候是三次握手-关闭的时候却是四次握手" aria-hidden="true">#</a> 1.为什么连接的时候是三次握手，关闭的时候却是四次握手？</h3><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>答：因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，&quot;你发的FIN报文我收到了&quot;。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_2-为什么time-wait状态需要经过2msl-最大报文段生存时间-才能返回到close状态" tabindex="-1"><a class="header-anchor" href="#_2-为什么time-wait状态需要经过2msl-最大报文段生存时间-才能返回到close状态" aria-hidden="true">#</a> 2.为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？</h3><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>答：虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可以最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。在Client发送出最后的ACK回复，但该ACK可能丢失。Server如果没有收到ACK，将不断重复发送FIN片段。所以Client不能立即关闭，它必须确认Server接收到了该ACK。Client会在发送出ACK之后进入到TIME_WAIT状态。Client会设置一个计时器，等待2MSL的时间。如果在该时间内再次收到FIN，那么Client会重发ACK并再次等待2MSL。所谓的2MSL是两倍的MSL(Maximum Segment Lifetime)。MSL指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="_3-为什么不能用两次握手进行连接" tabindex="-1"><a class="header-anchor" href="#_3-为什么不能用两次握手进行连接" aria-hidden="true">#</a> 3.为什么不能用两次握手进行连接？</h3><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>答：3次握手完成两个重要的功能，既要双方做好发送数据的准备工作(双方都知道彼此已准备好)，也要允许双方就初始序列号进行协商，这个序列号在握手过程中被发送和确认。

       现在把三次握手改成仅需要两次握手，死锁是可能发生的。作为例子，考虑计算机S和C之间的通信，假定C给S发送一个连接请求分组，S收到了这个分组，并发 送了确认应答分组。按照两次握手的协定，S认为连接已经成功地建立了，可以开始发送数据分组。可是，C在S的应答分组在传输中被丢失的情况下，将不知道S 是否已准备好，不知道S建立什么样的序列号，C甚至怀疑S是否收到自己的连接请求分
       组。在这种情况下，C认为连接还未建立成功，将忽略S发来的任何数据分 组，只等待连接确认应答分组。而S在发出的分组超时后，重复发送同样的分组。这样就形成了死锁。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_4-如果已经建立了连接-但是客户端突然出现故障了怎么办" tabindex="-1"><a class="header-anchor" href="#_4-如果已经建立了连接-但是客户端突然出现故障了怎么办" aria-hidden="true">#</a> 4.如果已经建立了连接，但是客户端突然出现故障了怎么办？</h3><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>答：TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><em>以上内容来自网络</em></p>`,19),t=[s];function c(h,u){return i(),a("div",null,t)}const m=e(r,[["render",c],["__file","index_12.html.vue"]]);export{m as default};
