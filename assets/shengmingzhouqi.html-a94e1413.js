import{_ as o,p as d,q as i,s as e,R as r,t as a,Y as n,n as l}from"./framework-aa5c4115.js";const h="/my-blog/images/vue3生命周期.jpg",s={},c=n('<h1 id="常用钩子" tabindex="-1"><a class="header-anchor" href="#常用钩子" aria-hidden="true">#</a> 常用钩子</h1><h2 id="ref" tabindex="-1"><a class="header-anchor" href="#ref" aria-hidden="true">#</a> ref</h2><h2 id="reactive" tabindex="-1"><a class="header-anchor" href="#reactive" aria-hidden="true">#</a> reactive</h2><h2 id="watch" tabindex="-1"><a class="header-anchor" href="#watch" aria-hidden="true">#</a> watch</h2><h2 id="computed" tabindex="-1"><a class="header-anchor" href="#computed" aria-hidden="true">#</a> computed</h2><h2 id="watcheffect" tabindex="-1"><a class="header-anchor" href="#watcheffect" aria-hidden="true">#</a> watchEffect</h2><h2 id="torefs" tabindex="-1"><a class="header-anchor" href="#torefs" aria-hidden="true">#</a> toRefs</h2><h2 id="onmounted" tabindex="-1"><a class="header-anchor" href="#onmounted" aria-hidden="true">#</a> onMounted</h2><h2 id="onbeforeunmount" tabindex="-1"><a class="header-anchor" href="#onbeforeunmount" aria-hidden="true">#</a> onBeforeUnmount</h2><h2 id="onactivated" tabindex="-1"><a class="header-anchor" href="#onactivated" aria-hidden="true">#</a> onActivated</h2><h2 id="ondeactivated" tabindex="-1"><a class="header-anchor" href="#ondeactivated" aria-hidden="true">#</a> onDeactivated</h2><h1 id="官网示意图" tabindex="-1"><a class="header-anchor" href="#官网示意图" aria-hidden="true">#</a> 官网示意图</h1><ul><li><img src="'+h+'" alt="vue3生命周期"></li></ul><h1 id="官网完整钩子" tabindex="-1"><a class="header-anchor" href="#官网完整钩子" aria-hidden="true">#</a> 官网完整钩子</h1><h2 id="beforecreate" tabindex="-1"><a class="header-anchor" href="#beforecreate" aria-hidden="true">#</a> beforeCreate</h2><p>在组件实例初始化完成之后立即调用。</p><ul><li><p><strong>详细信息</strong></p><p>会在实例初始化完成、props 解析之后、<code>data()</code> 和 <code>computed</code> 等选项处理之前立即调用。</p><p>注意，组合式 API 中的 <code>setup()</code> 钩子会在所有选项式 API 钩子之前调用，<code>beforeCreate()</code> 也不例外。</p></li></ul><h2 id="created" tabindex="-1"><a class="header-anchor" href="#created" aria-hidden="true">#</a> created</h2><p>在组件实例处理完所有与状态相关的选项后调用。</p><ul><li><p><strong>详细信息</strong></p><p>当这个钩子被调用时，以下内容已经设置完成：响应式数据、计算属性、方法和侦听器。然而，此时挂载阶段还未开始，因此 <code>$el</code> 属性仍不可用。</p></li></ul><h2 id="beforemount" tabindex="-1"><a class="header-anchor" href="#beforemount" aria-hidden="true">#</a> beforeMount</h2><p>在组件被挂载之前调用。</p><ul><li><p><strong>详细信息</strong></p><p>当这个钩子被调用时，组件已经完成了其响应式状态的设置，但还没有创建 DOM 节点。它即将首次执行 DOM 渲染过程。</p><p><strong>这个钩子在服务端渲染时不会被调用。</strong></p></li></ul><h2 id="mounted" tabindex="-1"><a class="header-anchor" href="#mounted" aria-hidden="true">#</a> mounted</h2><p>在组件被挂载之后调用。</p>',25),u=e("p",null,[e("strong",null,"详细信息")],-1),p=e("p",null,"组件在以下情况下被视为已挂载：",-1),_=e("ul",null,[e("li",null,[r("所有同步子组件都已经被挂载。(不包含异步组件或 "),e("code",null,"<Suspense>"),r(" 树内的组件)")]),e("li",null,"其自身的 DOM 树已经创建完成并插入了父容器中。注意仅当根容器在文档中时，才可以保证组件 DOM 树也在文档中。")],-1),f={href:"https://cn.vuejs.org/guide/scaling-up/ssr.html",target:"_blank",rel:"noopener noreferrer"},g=e("p",null,[e("strong",null,"这个钩子在服务端渲染时不会被调用。")],-1),b=n('<h2 id="beforeupdate" tabindex="-1"><a class="header-anchor" href="#beforeupdate" aria-hidden="true">#</a> beforeUpdate</h2><p>在组件即将因为一个响应式状态变更而更新其 DOM 树之前调用。</p><ul><li><p><strong>详细信息</strong></p><p>这个钩子可以用来在 Vue 更新 DOM 之前访问 DOM 状态。在这个钩子中更改状态也是安全的。</p><p><strong>这个钩子在服务端渲染时不会被调用。</strong></p></li></ul><h2 id="updated" tabindex="-1"><a class="header-anchor" href="#updated" aria-hidden="true">#</a> updated</h2><p>在组件因为一个响应式状态变更而更新其 DOM 树之后调用。</p>',5),m=e("p",null,[e("strong",null,"详细信息")],-1),x=e("p",null,"父组件的更新钩子将在其子组件的更新钩子之后调用。",-1),v={href:"https://cn.vuejs.org/api/general.html#nexttick",target:"_blank",rel:"noopener noreferrer"},k=e("p",null,[e("strong",null,"这个钩子在服务端渲染时不会被调用。")],-1),M=e("p",null,"WARNING",-1),D=e("p",null,"不要在 updated 钩子中更改组件的状态，这可能会导致无限的更新循环！",-1),O=n('<h2 id="beforeunmount" tabindex="-1"><a class="header-anchor" href="#beforeunmount" aria-hidden="true">#</a> beforeUnmount</h2><p>在一个组件实例被卸载之前调用。</p><ul><li><p><strong>详细信息</strong></p><p>当这个钩子被调用时，组件实例依然还保有全部的功能。</p><p><strong>这个钩子在服务端渲染时不会被调用。</strong></p></li></ul><h2 id="unmounted" tabindex="-1"><a class="header-anchor" href="#unmounted" aria-hidden="true">#</a> unmounted[]</h2><p>在一个组件实例被卸载之后调用。</p><ul><li><p><strong>详细信息</strong></p><p>一个组件在以下情况下被视为已卸载：</p><ul><li>其所有子组件都已经被卸载。</li><li>所有相关的响应式作用 (渲染作用以及 <code>setup()</code> 时创建的计算属性和侦听器) 都已经停止。</li></ul><p>可以在这个钩子中手动清理一些副作用，例如计时器、DOM 事件监听器或者与服务器的连接。</p><p><strong>这个钩子在服务端渲染时不会被调用。</strong></p></li></ul><h2 id="errorcaptured" tabindex="-1"><a class="header-anchor" href="#errorcaptured" aria-hidden="true">#</a> errorCaptured</h2><p>在捕获了后代组件传递的错误时调用。</p>',8),j=n("<p><strong>详细信息</strong></p><p>错误可以从以下几个来源中捕获：</p><ul><li>组件渲染</li><li>事件处理器</li><li>生命周期钩子</li><li><code>setup()</code> 函数</li><li>侦听器</li><li>自定义指令钩子</li><li>过渡钩子</li></ul><p>这个钩子带有三个实参：错误对象、触发该错误的组件实例，以及一个说明错误来源类型的信息字符串。</p><p>你可以在 <code>errorCaptured()</code> 中更改组件状态来为用户显示一个错误状态。然而重要的是，不要让错误状态渲染为导致本次错误的内容，否则组件就会进入无限的渲染循环中。</p><p>这个钩子可以通过返回 <code>false</code> 来阻止错误继续向上传递。请看下方的传递细节介绍。</p><p><strong>错误传递规则</strong></p>",7),C={href:"https://cn.vuejs.org/api/application.html#app-config-errorhandler",target:"_blank",rel:"noopener noreferrer"},w=e("code",null,"app.config.errorHandler",-1),N=n("<li>如果组件的继承链或组件链上存在多个 <code>errorCaptured</code> 钩子，对于同一个错误，这些钩子会被按从底至上的顺序一一调用。这个过程被称为“向上传递”，类似于原生 DOM 事件的冒泡机制。</li><li>如果 <code>errorCaptured</code> 钩子本身抛出了一个错误，那么这个错误和原来捕获到的错误都将被发送到 <code>app.config.errorHandler</code>。</li><li><code>errorCaptured</code> 钩子可以通过返回 <code>false</code> 来阻止错误继续向上传递。即表示“这个错误已经被处理了，应当被忽略”，它将阻止其他的 <code>errorCaptured</code> 钩子或 <code>app.config.errorHandler</code> 因这个错误而被调用。</li>",3),I=e("h2",{id:"rendertracked",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#rendertracked","aria-hidden":"true"},"#"),r(" renderTracked")],-1),V=e("p",null,"在一个响应式依赖被组件的渲染作用追踪后调用。",-1),y=e("p",null,[e("strong",null,"这个钩子仅在开发模式下可用，且在服务器端渲染期间不会被调用。")],-1),A=e("strong",null,"参考",-1),B={href:"https://cn.vuejs.org/guide/extras/reactivity-in-depth.html",target:"_blank",rel:"noopener noreferrer"},E=e("h2",{id:"rendertriggered",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#rendertriggered","aria-hidden":"true"},"#"),r(" renderTriggered")],-1),T=e("p",null,"在一个响应式依赖被组件触发了重新渲染之后调用。",-1),q=e("p",null,[e("strong",null,"这个钩子仅在开发模式下可用，且在服务器端渲染期间不会被调用。")],-1),H=e("strong",null,"参考",-1),P={href:"https://cn.vuejs.org/guide/extras/reactivity-in-depth.html",target:"_blank",rel:"noopener noreferrer"},R=e("h2",{id:"activated",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#activated","aria-hidden":"true"},"#"),r(" activated")],-1),U={href:"https://cn.vuejs.org/api/built-in-components.html#keepalive",target:"_blank",rel:"noopener noreferrer"},z=e("p",null,[e("strong",null,"这个钩子在服务端渲染时不会被调用。")],-1),L=e("strong",null,"参考",-1),S={href:"https://cn.vuejs.org/guide/built-ins/keep-alive.html#lifecycle-of-cached-instance",target:"_blank",rel:"noopener noreferrer"},G=e("h2",{id:"deactivated",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#deactivated","aria-hidden":"true"},"#"),r(" deactivated")],-1),W={href:"https://cn.vuejs.org/api/built-in-components.html#keepalive",target:"_blank",rel:"noopener noreferrer"},Y=e("p",null,[e("strong",null,"这个钩子在服务端渲染时不会被调用。")],-1),$=e("h2",{id:"serverprefetch",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#serverprefetch","aria-hidden":"true"},"#"),r(" serverPrefetch")],-1),F=e("p",null,"当组件实例在服务器上被渲染之前要完成的异步函数。",-1);function J(K,Q){const t=l("ExternalLinkIcon");return d(),i("div",null,[c,e("ul",null,[e("li",null,[u,p,_,e("p",null,[r("这个钩子通常用于执行需要访问组件所渲染的 DOM 树相关的副作用，或是在"),e("a",f,[r("服务端渲染应用"),a(t)]),r("中用于确保 DOM 相关代码仅在客户端被调用。")]),g])]),b,e("ul",null,[e("li",null,[m,x,e("p",null,[r("这个钩子会在组件的任意 DOM 更新后被调用，这些更新可能是由不同的状态变更导致的。如果你需要在某个特定的状态更改后访问更新后的 DOM，请使用 "),e("a",v,[r("nextTick()"),a(t)]),r(" 作为替代。")]),k,M,D])]),O,e("ul",null,[e("li",null,[j,e("ul",null,[e("li",null,[r("默认情况下，所有的错误都会被发送到应用级的 "),e("a",C,[w,a(t)]),r(" (前提是这个函数已经定义)，这样这些错误都能在一个统一的地方报告给分析服务。")]),N])])]),I,V,y,e("ul",null,[e("li",null,[A,e("a",B,[r("深入响应式系统"),a(t)])])]),E,T,q,e("ul",null,[e("li",null,[H,e("a",P,[r("深入响应式系统"),a(t)])])]),R,e("p",null,[r("若组件实例是 "),e("a",U,[r("``"),a(t)]),r(" 缓存树的一部分，当组件被插入到 DOM 中时调用。")]),z,e("ul",null,[e("li",null,[L,e("a",S,[r("指南 - 被缓存实例的生命周期"),a(t)])])]),G,e("p",null,[r("若组件实例是 "),e("a",W,[r("``"),a(t)]),r(" 缓存树的一部分，当组件从 DOM 中被移除时调用。")]),Y,$,F])}const Z=o(s,[["render",J],["__file","shengmingzhouqi.html.vue"]]);export{Z as default};
